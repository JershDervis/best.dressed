-- Create A Party by Calling this Function
create or replace function create_party(user_id uuid, party_name character varying) returns party
    language sql
as
$$
   WITH ins_party AS (
      INSERT INTO party ("name") VALUES(party_name) RETURNING *
   ), ins_host AS (
      INSERT INTO host ("user", "party") 
      SELECT U.id, ins_party.id FROM ins_party
      INNER JOIN auth.users U ON U.id=user_id
      RETURNING party
   ), ins_storage AS (
      INSERT INTO storage.objects ("bucket_id", "name")
      SELECT 'party', CONCAT(ins_party.room_uuid, '/.emptyFolderPlaceholder') FROM ins_party
      RETURNING *
   )
   SELECT * FROM ins_party;
$$;


-- Get all parties for a user by calling this function
CREATE OR REPLACE FUNCTION "get_user_parties"(user_id uuid, return_limit int) RETURNS SETOF party AS $$
    SELECT p.* FROM party p INNER JOIN host h ON h.party=p.id WHERE h.user=user_id ORDER BY p.created_at DESC LIMIT return_limit;
$$ LANGUAGE SQL;


CREATE OR REPLACE FUNCTION public.create_party(
	user_id uuid,
	party_name character varying)
    RETURNS party
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
   WITH ins_party AS (
      INSERT INTO party ("name") VALUES(party_name) RETURNING *
   ), ins_host AS (
      INSERT INTO host ("user", "party")
      SELECT U.id, ins_party.id FROM ins_party
      INNER JOIN auth.users U ON U.id=user_id
      RETURNING party
   ), ins_storage AS (
      INSERT INTO storage.objects ("bucket_id", "name")
      SELECT 'party', CONCAT(ins_party.room_uuid, '/.emptyFolderPlaceholder') FROM ins_party
      RETURNING *
   )
   SELECT * FROM ins_party;
$BODY$;

ALTER FUNCTION public.create_party(uuid, character varying)
    OWNER TO postgres_temporary_object_holder;

GRANT EXECUTE ON FUNCTION public.create_party(uuid, character varying) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.create_party(uuid, character varying) TO anon;

GRANT EXECUTE ON FUNCTION public.create_party(uuid, character varying) TO authenticated;

GRANT EXECUTE ON FUNCTION public.create_party(uuid, character varying) TO postgres;

GRANT EXECUTE ON FUNCTION public.create_party(uuid, character varying) TO postgres_temporary_object_holder;

GRANT EXECUTE ON FUNCTION public.create_party(uuid, character varying) TO service_role;

CREATE OR REPLACE FUNCTION public.get_user_parties(
	user_id uuid,
	return_limit integer)
    RETURNS SETOF party
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT p.* FROM party P
  INNER JOIN host H on H.party=P.id
  WHERE H.user="user_id"
  ORDER BY P.created_at DESC
  LIMIT("return_limit");
$BODY$;

ALTER FUNCTION public.get_user_parties(uuid, integer)
    OWNER TO postgres_temporary_object_holder;

GRANT EXECUTE ON FUNCTION public.get_user_parties(uuid, integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_user_parties(uuid, integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_user_parties(uuid, integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_user_parties(uuid, integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_user_parties(uuid, integer) TO postgres_temporary_object_holder;

GRANT EXECUTE ON FUNCTION public.get_user_parties(uuid, integer) TO service_role;

CREATE OR REPLACE FUNCTION public.get_party_entries(
	party_uuid uuid)
    RETURNS integer
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT COUNT(*) FROM storage.objects
  WHERE bucket_id='party'
  AND path_tokens[1]=party_uuid::text
$BODY$;

ALTER FUNCTION public.get_party_entries(uuid)
    OWNER TO postgres_temporary_object_holder;

GRANT EXECUTE ON FUNCTION public.get_party_entries(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_party_entries(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.get_party_entries(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_party_entries(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_party_entries(uuid) TO postgres_temporary_object_holder;

GRANT EXECUTE ON FUNCTION public.get_party_entries(uuid) TO service_role;

CREATE TABLE IF NOT EXISTS public.host
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    "user" uuid NOT NULL,
    party bigint NOT NULL,
    CONSTRAINT host_pkey PRIMARY KEY (id),
    CONSTRAINT host_party_fkey FOREIGN KEY (party)
        REFERENCES public.party (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT host_user_fkey FOREIGN KEY ("user")
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.host
    OWNER to postgres_temporary_object_holder;

ALTER TABLE IF EXISTS public.host
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.host TO postgres_temporary_object_holder;

GRANT ALL ON TABLE public.host TO postgres;

GRANT ALL ON TABLE public.host TO anon;

GRANT ALL ON TABLE public.host TO service_role;

GRANT ALL ON TABLE public.host TO authenticated;

COMMENT ON TABLE public.host
    IS 'A table of hosts for party''s';

COMMENT ON COLUMN public.host."user"
    IS 'The user ';

COMMENT ON COLUMN public.host.party
    IS 'The party that the user can manage';
CREATE POLICY "Enable read access for all users"
    ON public.host
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.party
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    room_uuid uuid NOT NULL DEFAULT uuid_generate_v4(),
    name character varying COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT "Party_pkey" PRIMARY KEY (id),
    CONSTRAINT "Party_link_key" UNIQUE (room_uuid)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.party
    OWNER to postgres_temporary_object_holder;

ALTER TABLE IF EXISTS public.party
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.party TO postgres_temporary_object_holder;

GRANT ALL ON TABLE public.party TO postgres;

GRANT ALL ON TABLE public.party TO anon;

GRANT ALL ON TABLE public.party TO service_role;

GRANT ALL ON TABLE public.party TO authenticated;

COMMENT ON TABLE public.party
    IS 'A party / room';
CREATE POLICY "Enable read access for all users"
    ON public.party
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.guest
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default" NOT NULL,
    photo_url character varying COLLATE pg_catalog."default",
    CONSTRAINT guest_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.guest
    OWNER to postgres_temporary_object_holder;

GRANT ALL ON TABLE public.guest TO postgres_temporary_object_holder;

GRANT ALL ON TABLE public.guest TO postgres;

GRANT ALL ON TABLE public.guest TO anon;

GRANT ALL ON TABLE public.guest TO service_role;

GRANT ALL ON TABLE public.guest TO authenticated;

COMMENT ON TABLE public.guest
    IS 'A guest that gets added to a party';